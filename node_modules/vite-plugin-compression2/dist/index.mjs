import t from"fs/promises";import e from"fs";import n from"os";import i from"path";import{createFilter as s}from"@rollup/pluginutils";import o from"zlib";import r from"util";import{createPack as a}from"tar-mini";function c(t){return t.length}function u(t,e){const n="function"==typeof e?e(t):e,{dir:s,base:o}=i.parse(t),r=s?s+"/":"";return n.replace(/\[path\]/,r).replace(/\[base\]/,o)}function l(t){return/^\\\\\?\\/.test(t)?t:t.replace(/\\/g,"/")}const p=new TextEncoder;function f(t){return"string"==typeof t?p.encode(t):t}function d(t){const e=t in o?t:"gzip";return{algorithm:r.promisify(o[e])}}async function m(t,e,n){try{return await e(t,n)}catch(t){return Promise.reject(t)}}const h={gzip:{level:o.constants.Z_BEST_COMPRESSION},brotliCompress:{params:{[o.constants.BROTLI_PARAM_QUALITY]:o.constants.BROTLI_MAX_QUALITY}},deflate:{level:o.constants.Z_BEST_COMPRESSION},deflateRaw:{level:o.constants.Z_BEST_COMPRESSION}};class y{constructor(t){this.maxConcurrent=t,this.queue=[],this.errors=[],this.running=0}enqueue(t){this.queue.push(t),this.run()}async run(){for(;this.running<this.maxConcurrent&&this.queue.length;){const t=this.queue.shift();this.running++;try{await t()}catch(t){this.errors.push(t)}finally{this.running--,this.run()}}}async wait(){for(;this.running;)await new Promise((t=>setTimeout(t,0)));if(c(this.errors))throw new AggregateError(this.errors,"task failed")}}function g(t){return new y(t)}const w="vite-plugin-compression",b=(()=>{const t=n.cpus()||{length:1};return 1===t.length?10:Math.max(1,t.length-1)})();function O(t){const e=new Set,n=(t,e)=>l(i.resolve(t,e));if(t.build.rollupOptions?.output){(Array.isArray(t.build.rollupOptions.output)?t.build.rollupOptions.output:[t.build.rollupOptions.output]).forEach((i=>{("object"!=typeof i||c(Object.keys(i)))&&e.add(n(t.root,i.dir||t.build.outDir))}))}else e.add(n(t.root,t.build.outDir));return e}async function v(n,s){const o=!("copyPublicDir"in n.build)||n.build.copyPublicDir;if(n.publicDir&&o&&e.existsSync(n.publicDir)){const e=await async function(e){const n=await Promise.all((await t.readdir(e)).map((t=>i.join(e,t))));let s=0;const o=[];for(;s!==c(n);){const e=n[s],r=await t.stat(e);if(r.isDirectory()){const s=await t.readdir(e);n.push(...s.map((t=>i.join(e,t))))}r.isFile()&&o.push(e),s++}return o}(n.publicDir),o=i.join(n.root,i.relative(n.root,n.publicDir));await Promise.all(e.map((async t=>{const e=l(i.relative(o,t));await s(e,t)})))}}function P(n={}){const{dest:s,gz:r=!1}=n,c=[],u=[];let p=[],d=process.cwd();const m=function(){const t=a(),n={dests:[],root:"",gz:!1};return{add:e=>{t.add(f(e.content),{filename:e.filename})},setup:async s=>{Object.assign(n,s);const r=n.dests.map((s=>{const r=l(i.resolve(n.root,s+".tar"+(n.gz?".gz":""))),a=l(i.dirname(r));return l(n.root)!==a&&e.mkdirSync(a,{recursive:!0}),new Promise(((i,s)=>{const a=e.createWriteStream(r);a.on("error",s),a.on("finish",i),n.gz?t.receiver.pipe(o.createGzip()).pipe(a):t.receiver.pipe(a)}))}));return Promise.all(r)},done:()=>t.done()}}(),h=g(b);let y;return{name:"vite-plugin-tarball",enforce:"post",async configResolved(t){u.push(...O(t)),d=t.root,p=s?[s]:u,y=j.getPluginAPI(t.plugins),y||await v(t,(async t=>{c.push(t)})),m.setup({dests:p,root:d,gz:r})},async writeBundle(t,e){for(const t in e){const n=e[t];m.add({filename:t,content:"asset"===n.type?n.source:n.code})}},async closeBundle(){!c.length&&y&&y.staticOutputs.size&&c.push(...y.staticOutputs);for(const e of u)for(const n of c)h.enqueue((async()=>{const s=i.join(e,n),o=await t.readFile(s);m.add({filename:n,content:o})}));await h.wait(),m.done()}}}function j(e={}){const{include:n=/\.(html|xml|css|json|js|mjs|svg|yaml|yml|toml)$/,exclude:o,threshold:r=0,algorithm:a="gzip",filename:l,compressionOptions:p,deleteOriginalAssets:y=!1,skipIfLargerOrEqual:P=!0}=e,j=s(n,o),z=[],S=[],A=Object.create(null);A.algorithm="string"==typeof a?d(a).algorithm:a,A.options="function"==typeof a?p:Object.assign(h[a],p),A.filename=l??("brotliCompress"===a?"[path][base].br":"[path][base].gz");const E=g(b),B=async function(t,e){for(const t in e){if(!j(t))continue;const n=e[t],i=f("asset"===n.type?n.source:n.code),s=c(i);s<r||E.enqueue((async()=>{const n=u(t,A.filename),o=await m(i,A.algorithm,A.options);P&&c(o)>=s||((y||t===n)&&Reflect.deleteProperty(e,t),this.emitFile({type:"asset",fileName:n,source:o}))}))}await E.wait().catch(this.error)},I={staticOutputs:new Set};return{name:w,apply:"build",enforce:"post",api:I,async configResolved(t){S.push(...O(t)),await v(t,(async t=>{z.push(t)}));const e=t.plugins.find((t=>"vite:build-import-analysis"===t.name));if(!e)throw new Error("[vite-plugin-compression] Can't be work in versions lower than vite at 2.0.0");!async function(t,e){const n=t.generateBundle;if("object"==typeof n&&n.handler){const t=n.handler;n.handler=async function(...n){await t.apply(this,n),await e.apply(this,n)}}"function"==typeof n&&(t.generateBundle=async function(...t){await n.apply(this,t),await e.apply(this,t)})}(e,B)},async closeBundle(){const e=async(e,n)=>{const s=i.join(e,n);if(!j(s)&&!I.staticOutputs.has(n))return void I.staticOutputs.add(n);const{size:o}=await t.stat(s);o<r?I.staticOutputs.has(n)||I.staticOutputs.add(n):await(async(e,n,s)=>{const o=await t.readFile(e),r=await m(o,A.algorithm,A.options);if(P&&c(r)>=c(o))return void(I.staticOutputs.has(e)||I.staticOutputs.add(e));const a=u(n,A.filename);I.staticOutputs.has(a)||I.staticOutputs.add(a);const l=i.join(s,a);y&&l!==e&&await t.rm(e,{recursive:!0,force:!0}),await t.writeFile(l,r)})(s,n,e)};for(const t of S)for(const n of z)E.enqueue((()=>e(t,n)));await E.wait().catch((t=>t))}}}function z(t){return t}j.getPluginAPI=t=>t.find((t=>t.name===w))?.api;export{j as compression,j as default,z as defineCompressionOption,P as tarball};
